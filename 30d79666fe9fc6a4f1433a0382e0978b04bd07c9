{
  "comments": [
    {
      "key": {
        "uuid": "a8ebfaad_1ae17730",
        "filename": "include/v8.h",
        "patchSetId": 6
      },
      "lineNbr": 2747,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2018-08-29T12:31:55Z",
      "side": 1,
      "message": "Not sure what cachable means here or what we are meant to do if it isn\u0027t cacheable. Can we not just have Lock / Unlock be noops if the string doesn\u0027t move?",
      "range": {
        "startLine": 2747,
        "startChar": 4,
        "endLine": 2747,
        "endChar": 66
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b2a5069_ef490ff9",
        "filename": "include/v8.h",
        "patchSetId": 6
      },
      "lineNbr": 2756,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2018-08-29T12:31:55Z",
      "side": 1,
      "message": "I\u0027d prefer these aren\u0027t called explicitly by most code. Could we move the have the scoped locker class be the mechanism used by V8 code to lock / unlock these strings (i.e., move that to live in v8.h / api.cc and have it be a friend class of ExternalStringResourceBase so that it call call private lock / unlock functions. Also, could we make it clearer (in comments) that these functions increment the lock count, and it is only unlocked on the final call to unlock. \n\nAs a higher level point, I think we should make it more explicit in V8 what strings might need to be locked. Could we add a wrapper class (MoveableExternalString or similar) that wraps an ExternalStringResourceBase but only allows access to it when the lock is held? We would need to change a bit more code to make CharacterStreams take a MoveableExternalString explicitly, but I think this would make it much clearer on the V8 side when we have a string that needs to be locked.  Toon, WDYT?",
      "range": {
        "startLine": 2755,
        "startChar": 3,
        "endLine": 2756,
        "endChar": 34
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a216c06e_da255698",
        "filename": "include/v8.h",
        "patchSetId": 6
      },
      "lineNbr": 2756,
      "author": {
        "id": 1132034
      },
      "writtenOn": "2018-08-29T12:58:43Z",
      "side": 1,
      "message": "For the first point, thanks, will do.\n\nFor the second one, I have a local patch which does that, but was a bit concerned with the overhead. It was also more intrusive to lock every ExternalString access, as all the non-flat strings can contain ExternalStrings as components IIUC.\n\nFrom an offline discussion with Toon and Yang, it seemed unnecessary as no access outlives the current task, but I let Toon comment on that.",
      "parentUuid": "3b2a5069_ef490ff9",
      "range": {
        "startLine": 2755,
        "startChar": 3,
        "endLine": 2756,
        "endChar": 34
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08a9c3fd_8fbb35d0",
        "filename": "include/v8.h",
        "patchSetId": 6
      },
      "lineNbr": 2756,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2018-08-29T14:37:45Z",
      "side": 1,
      "message": "It\u0027d be a nice guarantee to have if it\u0027s somewhat straightforward, but as Benoit says, I\u0027m not too worried about it. There aren\u0027t many V8 accesses that outlive the current task and there likely won\u0027t be beyond parallel compilation.",
      "parentUuid": "a216c06e_da255698",
      "range": {
        "startLine": 2755,
        "startChar": 3,
        "endLine": 2756,
        "endChar": 34
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d14b1af_f387cf9d",
        "filename": "include/v8.h",
        "patchSetId": 6
      },
      "lineNbr": 2757,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2018-08-29T12:31:55Z",
      "side": 1,
      "message": "Please add whitespace between functions",
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "438ec8d6_0a5be472",
        "filename": "src/parsing/scanner-character-streams.cc",
        "patchSetId": 6
      },
      "lineNbr": 29,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2018-08-29T12:31:55Z",
      "side": 1,
      "message": "Do these happen? What happens if we have an uncached string, why wouldn\u0027t we need to lock in these cases?",
      "range": {
        "startLine": 29,
        "startChar": 4,
        "endLine": 29,
        "endChar": 50
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdaddcdc_fafb5c5c",
        "filename": "src/parsing/scanner-character-streams.cc",
        "patchSetId": 6
      },
      "lineNbr": 29,
      "author": {
        "id": 1132034
      },
      "writtenOn": "2018-08-29T12:58:43Z",
      "side": 1,
      "message": "The first one happen in tests, the second happens because not all ExternalStrings are uncached. But we could lock them nonetheless.",
      "parentUuid": "438ec8d6_0a5be472",
      "range": {
        "startLine": 29,
        "startChar": 4,
        "endLine": 29,
        "endChar": 50
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9230fdf3_43c5fa71",
        "filename": "src/parsing/scanner-character-streams.cc",
        "patchSetId": 6
      },
      "lineNbr": 46,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2018-08-29T12:31:55Z",
      "side": 1,
      "message": "Setting resource to nullptr on moves seems a bit confusing. Can we just disallow moving / copying with DISALLOW_COPY_AND_MOVE_AND_ASSIGN, and add an explicit method for cloning the lock to make it explicit that this causes the string to increment the lock count.",
      "range": {
        "startLine": 46,
        "startChar": 1,
        "endLine": 46,
        "endChar": 60
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0fbdbc4_3592434a",
        "filename": "src/parsing/scanner-character-streams.cc",
        "patchSetId": 6
      },
      "lineNbr": 46,
      "author": {
        "id": 1132034
      },
      "writtenOn": "2018-08-29T12:58:43Z",
      "side": 1,
      "message": "This was done to avoid needless Lock()/Unlock() increments with the copy constructor.\nCopying requires less code changes elsewhere as (Un)BufferedCharacterStream::Clone() calls the copy constructor of ExternalStringStream.\nAlso, this maps to what std::unique_ptr\u003cT\u003e does.\n\nI can either add comments to make this more explicit, or change, up to you.",
      "parentUuid": "9230fdf3_43c5fa71",
      "range": {
        "startLine": 46,
        "startChar": 1,
        "endLine": 46,
        "endChar": 60
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10d49f79_d5071d61",
        "filename": "src/parsing/scanner-character-streams.cc",
        "patchSetId": 6
      },
      "lineNbr": 46,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2018-08-29T13:36:29Z",
      "side": 1,
      "message": "\u003e This was done to avoid needless Lock()/Unlock() increments with the copy constructor.\n\nThe copy constructor takes the value by const reference, so shouldn\u0027t do unecessary Lock()/Unlocks() so shouldn\u0027t invoke the move constructor anyway, or am I missing something?\n\n\u003e calls the copy constructor of ExternalStringStream.\n\nSure, but that doesn\u0027t stop you from doing lock_(other.lock_.Clone()) or similar in the ExternalStringStream copy constructor :).",
      "parentUuid": "c0fbdbc4_3592434a",
      "range": {
        "startLine": 46,
        "startChar": 1,
        "endLine": 46,
        "endChar": 60
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8c3f559_8d76f5d3",
        "filename": "src/parsing/scanner-character-streams.cc",
        "patchSetId": 6
      },
      "lineNbr": 46,
      "author": {
        "id": 1132034
      },
      "writtenOn": "2018-08-29T13:45:12Z",
      "side": 1,
      "message": "Ah, sorry, the extra Lock()/Unlock() is during the ExternalStringStream object creation, from the BufferedCharacterStream constructor.\n\nEssentially, the lock must be created before calling ExternalString::GetChars(), because:\n- ExternalString::GetChars() must be protected by the lock (otherwise the pointer could move between the GetChars() call and the lock)\n- Argument evaluation order is unspecified in C++\n\nSo in\n  ScopedExternalStringLock lock(string);\n  return new BufferedCharacterStream\u003cExternalStringStream\u003e(\n      static_cast\u003csize_t\u003e(start_pos), std::move(lock),\n      string-\u003eGetChars() + start_offset, static_cast\u003csize_t\u003e(end_pos));\n\nThere is an extra Lock()/Unlock() pair from the local variable lock which is avoided with the move constructor.\n\nThis is a bit tricky, but as this is the same as what happens with std::lock_guard and std::unique_ptr, I thought this would be fine.",
      "parentUuid": "10d49f79_d5071d61",
      "range": {
        "startLine": 46,
        "startChar": 1,
        "endLine": 46,
        "endChar": 60
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6557e7d0_1019d364",
        "filename": "src/parsing/scanner-character-streams.cc",
        "patchSetId": 6
      },
      "lineNbr": 46,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2018-08-29T13:52:41Z",
      "side": 1,
      "message": "Ahh right I see. Personally I\u0027d prefer to see this lock object always have resource_ !\u003d nullptr so that we know that it is always locking a resource (doing things wrong might leave you with an empty ScopedExternalStringLock not locking anything). Maybe this is something that the wrapper object comment on the other file can help with.",
      "parentUuid": "a8c3f559_8d76f5d3",
      "range": {
        "startLine": 46,
        "startChar": 1,
        "endLine": 46,
        "endChar": 60
      },
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dcd33192_2675b60c",
        "filename": "src/parsing/scanner-character-streams.cc",
        "patchSetId": 6
      },
      "lineNbr": 803,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2018-08-29T14:37:45Z",
      "side": 1,
      "message": "Wouldn\u0027t it be simpler to change ExternalString to have something like GetChar() (which is simply resource()-\u003edata() anyway), make ExternalStringString take an ExternalString and create the lock itself?",
      "revId": "30d79666fe9fc6a4f1433a0382e0978b04bd07c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}