{
  "comments": [
    {
      "key": {
        "uuid": "a0b711fa_1a4856fd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 18,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2020-08-20T07:48:38Z",
      "side": 1,
      "message": "Having a separate Allocate/Init to the writes seems dangerous, a caller could forget to do the allocation. Allocating in the setter (avoiding reallocation if a field is already allocated) doesn\u0027t seem that big an issue to me, esp. since the table is malloced?",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 68
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59f79ea2_38a714ee",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 18,
      "author": {
        "id": 1412532
      },
      "writtenOn": "2020-08-20T12:06:10Z",
      "side": 1,
      "message": "I think one argument in favor of this approach is that it doesn\u0027t suddenly make a fairly cheap operation (writing an external pointer value to an object) expensive (it could trigger reallocation or even GC of the table). The other reason, as ishell@ pointed out, might be that currently, write operations are not expected to trigger something complex like GC, which could cause other trouble.\nIt seems to me that an uninitialized external slot should be quickly caught during testing as it should lead to a crash most of the time, but maybe I\u0027m a bit too naive here :)",
      "parentUuid": "a0b711fa_1a4856fd",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 68
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a39c7f3_cf7dc10e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 18,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2020-08-20T13:19:15Z",
      "side": 1,
      "message": "The external table is malloced, so allocating/reallocating it won\u0027t trigger any GCs.",
      "parentUuid": "59f79ea2_38a714ee",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 68
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69d1adc5_7caa2a9f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 18,
      "author": {
        "id": 1412532
      },
      "writtenOn": "2020-08-20T14:17:40Z",
      "side": 1,
      "message": "Well in this prototype it is, later on it might be allocated in some other way (e.g. it could grow downwards from the start of the 4GB heap region). But yes, it\u0027s unlikely that it will be allocated through the V8 heap allocator. However regardless of how it is allocated, it could still be the case that an allocation of a new table entry would require a table GC (if some maximum size is reached or something like that) which then probably also requires a \"normal\" GC to figure out which entries are alive, no?",
      "parentUuid": "1a39c7f3_cf7dc10e",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 68
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62421196_2ac984ab",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 18,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2020-08-20T14:59:01Z",
      "side": 1,
      "message": "I would posit that the whole point of this project is that this table isn\u0027t allocated through the heap allocator! I suppose it could still trigger GC heuristics though.\n\nI personally feel that the \"risk\" of forgetting an allocate is greater than the conceptual simplification of no-allocate-during-set, but I\u0027m happy to defer to other reviewers on this.",
      "parentUuid": "69d1adc5_7caa2a9f",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 68
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6bf90f6f_3880b832",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 18,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2020-08-20T16:17:12Z",
      "side": 1,
      "message": "Pre-allocating a most-likely necessary entry also simplifies the code that reads/writes through that entry as no branches are required and the access is straight forward.\nI also think that the \"risk of not allocating an entry\" is quite low because of the quite limited number of places where we store external pointers + immediate crash that will follow the attempt to store through a non-initialized entry.",
      "parentUuid": "62421196_2ac984ab",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 68
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e379174e_4b828810",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 18,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2020-08-21T06:22:31Z",
      "side": 1,
      "message": "Ok, as I said I\u0027m happy to defer to you on this since it\u0027s effectively personal preference.",
      "parentUuid": "6bf90f6f_3880b832",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 68
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0cd2022c_26e2e395",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 26,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2020-08-20T07:48:38Z",
      "side": 1,
      "message": "have you run this past the GC team? I would expect a mechanism more similar to external strings, where there\u0027s an external string table that holds weak refs to the external string objects, and which the GC walks to check if the strings are still alive.",
      "range": {
        "startLine": 26,
        "startChar": 1,
        "endLine": 26,
        "endChar": 40
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3072b051_1f9a11df",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 26,
      "author": {
        "id": 1412532
      },
      "writtenOn": "2020-08-20T12:06:10Z",
      "side": 1,
      "message": "Ah this comment is probably wrong, it can\u0027t use object finalizers (because they don\u0027t exist :D). This CL: https://chromium-review.googlesource.com/c/v8/v8/+/2252179/3 implements basic GC support for the table, but it\u0027s more like the ArrayBuffer tracker than the external string table (I think)",
      "parentUuid": "0cd2022c_26e2e395",
      "range": {
        "startLine": 26,
        "startChar": 1,
        "endLine": 26,
        "endChar": 40
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be8a12ff_164eb7ba",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 26,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2020-08-20T13:19:15Z",
      "side": 1,
      "message": "Ok, this works too -- it might have issues with concurrent heap access but I\u0027ll let the GC team raise them if they\u0027re relevant.",
      "parentUuid": "3072b051_1f9a11df",
      "range": {
        "startLine": 26,
        "startChar": 1,
        "endLine": 26,
        "endChar": 40
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6fc49529_67d10865",
        "filename": "BUILD.gn",
        "patchSetId": 18
      },
      "lineNbr": 312,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2020-08-20T07:48:38Z",
      "side": 1,
      "message": "should this have \u0027\u0026\u0026 v8_enable_pointer_compression\u0027 ?",
      "range": {
        "startLine": 312,
        "startChar": 27,
        "endLine": 312,
        "endChar": 50
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5cacbd40_e775d6ee",
        "filename": "BUILD.gn",
        "patchSetId": 18
      },
      "lineNbr": 312,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2020-08-25T16:40:47Z",
      "side": 1,
      "message": "This change is temporary here just for testing the CL on the bots. It will not be landed.",
      "parentUuid": "6fc49529_67d10865",
      "range": {
        "startLine": 312,
        "startChar": 27,
        "endLine": 312,
        "endChar": 50
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f86f23c_199b313e",
        "filename": "include/v8-internal.h",
        "patchSetId": 18
      },
      "lineNbr": 176,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2020-08-20T07:48:38Z",
      "side": 1,
      "message": "I\u0027m not sure I understand what this offset is for -- is it a slot within the slot? Should its value actually be \"kApiSystemPointerSize - kApiTaggedSize\"?",
      "range": {
        "startLine": 176,
        "startChar": 19,
        "endLine": 176,
        "endChar": 52
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1bb51b0f_6bd7d179",
        "filename": "include/v8-internal.h",
        "patchSetId": 18
      },
      "lineNbr": 176,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2020-08-25T16:40:47Z",
      "side": 1,
      "message": "kApiSystemPointerSize \u003d kApiTaggedSize * 2 when sandbox is enabled.\nThe value of this constant actually depends on the endianness: for LE it\u0027ll be kApiTaggedSize, for BE it\u0027ll be 0. The reason is explained below. Since we are developing this prototype only for x64 we don\u0027t bother propagating and using macro values that can be used for endianness detection, so we just define this constant for LE case.\n\nNormally, we write aligned external pointers as Word-size values into embedder data slots. The fact that they are aligned allows this value look like a Smi. When pointer compression is enabled the Word-size value \"looks\" like two \"Tagged\"-size values: the lower 32-bits part looks like Smi but the upper part is actually raw and is not guaranteed to look like a Smi. So, GC skips the raw parts of embedder data slots and looks only at the tagged part.\nIn a sandbox mode we read/write 32-bit external table index value directly from/into the raw part of the embedder data slot.",
      "parentUuid": "8f86f23c_199b313e",
      "range": {
        "startLine": 176,
        "startChar": 19,
        "endLine": 176,
        "endChar": 52
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4c92ee7_a6da5afe",
        "filename": "include/v8-internal.h",
        "patchSetId": 18
      },
      "lineNbr": 176,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2020-09-08T14:37:12Z",
      "side": 1,
      "message": "Ok, can we static assert somewhere that it\u0027s equivalent to something else? It currently only seems to be used in v8.h, so it\u0027s not clear to me how it\u0027s used internally.\n\nWhy is the embedder data slot word-sized instead of tagged-sized in the sandbox mode anyway, if it\u0027s just storing an index value?",
      "parentUuid": "1bb51b0f_6bd7d179",
      "range": {
        "startLine": 176,
        "startChar": 19,
        "endLine": 176,
        "endChar": 52
      },
      "revId": "532788fd137a7f0d9a333706beb91403c80995b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}