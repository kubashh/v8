{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f41805b3_32bd9162",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 3371466
      },
      "writtenOn": "2024-04-09T11:44:30Z",
      "side": 1,
      "message": "Hey, could you please take a look at my changes?",
      "revId": "2aed0bfe2dd6238b12b020f8630b02a586912180",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "abcc33ad_6759264a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1141154
      },
      "writtenOn": "2024-04-10T06:11:55Z",
      "side": 1,
      "message": "I think this fix goes in the wrong direction. Liftoff keeps a internal version of the wasm value stack, and for each stack slot, Liftoff knows if the slot value is currently cached in a register or not. Multiple slots can be cached in the same register. The number of slots cached with the same register is stored in `cache_state_.get_use_count(reg)`.\n\nAs far as I understand your CL description and the changed code, a register should get spilled but when the end of the stack is reached, Liftoff still thinks that there are stack slots left that have their value cached in the register. This means probably, that `cache_state_.get_use_count(reg)` is out of sync. It would be better to figure out why the cache state is out of sync. This CL makes Liftoff continue with an invalid state, which may lead to the generation of incorrect code.\n\nIf you compile V8 with the gn arg `v8_enable_slow_dchecks` to enable the DCHECK in [1], maybe in combination with --trace-liftoff and --trace-wasm-decoder, you should be able to find the instruction when the cache state gets invalid and why.\n\nIf you need more help, please ask.\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:v8/src/wasm/baseline/liftoff-compiler.cc;l\u003d1328;drc\u003def58cad72c78506b85c55ace095200cc1d31c4de",
      "revId": "2aed0bfe2dd6238b12b020f8630b02a586912180",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67d6b7a6_6ed12381",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1177599
      },
      "writtenOn": "2024-04-10T08:32:50Z",
      "side": 1,
      "message": "+1, this should be fixed by making our invariants hold again.\n\nWith slow DCHECKs we also run `ValidateCacheState()` after every instruction, which ensures that the register use counters are consistent with the current cache state. See https://source.chromium.org/chromium/chromium/src/+/main:v8/src/wasm/baseline/liftoff-compiler.cc;l\u003d1328;drc\u003def58cad72c78506b85c55ace095200cc1d31c4de.",
      "parentUuid": "abcc33ad_6759264a",
      "revId": "2aed0bfe2dd6238b12b020f8630b02a586912180",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e6402e6_bcf2cd00",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 3371466
      },
      "writtenOn": "2024-04-15T12:07:21Z",
      "side": 1,
      "message": "Thank you for your insightful reviews. Upon examination, we have identified an out-of-bound error concerning the `idx` variable.\n\nAs observed, the loop decrements `idx` by 1 in each iteration and only terminates when `remaining_uses` reaches 0. Additionally, the presence of a `continue` statement within the loop potentially prevents the decrement of `remaining_uses` indefinitely.\n\nDuring our testing phase, `remaining_uses` was initialized to 1, and `idx` was set to 327. The loop consistently executed the `continue` statement, maintaining `remaining_uses` at 1, while `idx` was reduced to 0. Subsequently, in the following iteration, `idx` experienced an integer overflow, resulting in a value of 4294967295. Given that this value exceeds `stack_height`, an access violation exception occurred at the line: `auto* slot \u003d \u0026cache_state_.stack_state[idx];`.\n\nThis situation would occur regardless of the value of `remaining_uses` since it was never decremented. In addition, it is an undefined behavior and it should be avoided as much as possible.\n\nMy knowledge of this code is very limited as I got here through debugging it from Node.js.",
      "parentUuid": "67d6b7a6_6ed12381",
      "revId": "2aed0bfe2dd6238b12b020f8630b02a586912180",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57a9b916_3cdb90e9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1141154
      },
      "writtenOn": "2024-04-15T12:22:45Z",
      "side": 1,
      "message": "Hi HÃ¼seyin,\n\nif you send us the wasm module that triggers this bug, then we can investigate the issue for you. A good way to send us the wasm module would be to file a bug at https://issues.chromium.org/issues/new?component\u003d1456332\u0026template\u003d1923191 and assign it to ahaas@chromium.org.",
      "parentUuid": "1e6402e6_bcf2cd00",
      "revId": "2aed0bfe2dd6238b12b020f8630b02a586912180",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4fd1036b_3886ed65",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 3371466
      },
      "writtenOn": "2024-04-17T15:33:11Z",
      "side": 1,
      "message": "Hi Andreas, \nIn Node, we create wasm files from the corresponding c files in Linux and use these created files on all platforms. For this case, I have a wasm file created from a c file that fails. I can provide you with both. I\u0027ve tested this in Node, not in V8. Is there some way to test this wasm file in V8 directly, and if yes, can you tell me how to do it?",
      "parentUuid": "57a9b916_3cdb90e9",
      "revId": "2aed0bfe2dd6238b12b020f8630b02a586912180",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88762f03_4ed47617",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1141154
      },
      "writtenOn": "2024-04-17T16:50:40Z",
      "side": 1,
      "message": "There are multiple ways. One is to write a small js wrapper, e.g.\n```\nconst buffer \u003d readbuffer(\u0027file.wasm\u0027);\nnew WebAssembly.Module(buffer);\n```\nand compile it with\n`./d8 --liftoff-only --no-wasm-lazy-compilation wrapper.js`\n\nThis assumes that you compiled d8, the js wrapper is saved as wrapper.js, and the wasm module is available as file.wasm.\n\nAn alternative would be to compile v8_simple_wasm_fuzzer, and call it with\n`v8_simple_wasm_fuzzer file.wasm`\n\nBut as I said, if you give me the .wasm file, I can investigate the issue as well.",
      "parentUuid": "4fd1036b_3886ed65",
      "revId": "2aed0bfe2dd6238b12b020f8630b02a586912180",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}