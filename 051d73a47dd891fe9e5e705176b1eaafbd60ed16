{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "32bfcdbb_d5c7d0c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-13T19:01:08Z",
      "side": 1,
      "message": "@syg@chromium.org PTAL. This still doesn\u0027t fix the flakiness reported on bug 339021674, but should get rid of the use after free, and hopefully throw a better error.",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b0f797a3_9b9f1b6d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-05-13T23:01:26Z",
      "side": 1,
      "message": "I presented two options in notes below, both of which I think would be cleaner. What\u0027s your preference?",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "803c051f_2c317b94",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 800,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-05-13T23:01:26Z",
      "side": 1,
      "message": "Nit: stray \u0027s?",
      "range": {
        "startLine": 800,
        "startChar": 58,
        "endLine": 800,
        "endChar": 60
      },
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d337c847_daefb754",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 800,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-14T01:37:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "803c051f_2c317b94",
      "range": {
        "startLine": 800,
        "startChar": 58,
        "endLine": 800,
        "endChar": 60
      },
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "01806252_67377c99",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 874,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-05-13T23:01:26Z",
      "side": 1,
      "message": "I\u0027m wondering if we can always allocate async waiter at this point, instead of sometimes being passed in and sometimes allocating here.\n\nThe reason to avoid allocations inside critical sections inside locks is that it makes them more flexible, as otherwise they cannot be used inside allocators without deadlock.\n\nIn our case, no one will use this implementation inside a `malloc` implementation. It has a very slim chance to be used inside V8\u0027s own allocators, so it seems wiser to avoid doing V8 heap allocations inside to avoid ever having to think about weird reentrancy cases.\n\nGiven the above, there may be a way to structure this such that we can allocate a `WaiterQueueNode` as late as possible, because that\u0027s a `malloc` allocation, but preallocate all the Promise and handler stuff.\n\nLet\u0027s call this Option B, which is mutually exclusive with Option A.",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd3a3196_51a98e6e",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 874,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-13T23:54:12Z",
      "side": 1,
      "message": "This is what I\u0027d like to do, and what we were doing before this change. The issue is that we need to store a reference to the `WaiterQueueNode` in the handlers\u0027 context. So the options I thought were to:\n1. Preallocate the `WaiterQueueNode` (this solution).\n2. Allocate a `WaiterQueueNode**` in the heap, store it in the context and then change its content to the `WaiterQueueNode*` created here. Which seemed less clean.\n\nAn alternative solution that I just thought is for `SetAsyncUnlockHandlers` to return the async unlock handlers\u0027 context, and add the node to the context slot after the `AsyncLock` call. It seems a little weird to update the context after setting the handlers but it may end up being cleaner that this. WDYT?",
      "parentUuid": "01806252_67377c99",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca5c6872_7f4083f2",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 874,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-14T01:37:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fd3a3196_51a98e6e",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66a2e781_ac933355",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 879,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-05-13T23:01:26Z",
      "side": 1,
      "message": "To make sure I understand, it\u0027s the destructor on `waiter_node` that is racing, because a waiter node is enqueued _before_ setting promise handlers, and if setting the handlers fail, cleanup logic is done on the waiter node that\u0027s now in the queue without taking the queue lock.\n\nI don\u0027t understand the `AddWaitingData` and `ClearWaitingData` dance though.",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b776f79_52269250",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 879,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-13T23:54:12Z",
      "side": 1,
      "message": "Yes, that\u0027s the race. `ClearWaitingData` is clearing unnecessary information. The task runner must be set before making the node visible to other threads, so that\u0027s why I\u0027m setting the data right before `MaybeEnqueNode`, ideally we could do it inside `MaybeEnqueueNode` but then we couldn\u0027t reuse the code. TL;DR I don\u0027t have a strong argument to keep it this wait and hopefully we can remove it with the solution I explained above.",
      "parentUuid": "66a2e781_ac933355",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "35af77e1_7257592a",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 879,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-14T01:37:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3b776f79_52269250",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66727599_888bb452",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 957,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-05-13T23:01:26Z",
      "side": 1,
      "message": "It feels off for `SetAsyncUnlockHandlers` to be also doing lifetime management in case of failure. Can `NewAsyncWaiterStoredInIsolate` take an initialization lambda so that it doesn\u0027t add the waiter to the queue list at all if `PerformPromiseThen` fails? Also in that case do we still need the `ClearWaitingData` dance?\n\nLet\u0027s call this Option A, which is in conflict with Option B which is about moving the allocation of `WaiterQueueNode` entirely.",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ced1e997_9dde05c9",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 957,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-13T23:54:12Z",
      "side": 1,
      "message": "I\u0027d like to keep `NewAsyncWaiterStoredInIsolate` as a simple wrapper of the constructor which also adds the node to the isolate\u0027s list, maybe we don\u0027t need this if the option I explained above works.",
      "parentUuid": "66727599_888bb452",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c603924_d244310a",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 2
      },
      "lineNbr": 957,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-14T01:37:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ced1e997_9dde05c9",
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6cb5166b_f9846bb3",
        "filename": "src/objects/js-atomics-synchronization.h",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-05-13T23:01:26Z",
      "side": 1,
      "message": "It\u0027s the C++ heap, not stack.",
      "range": {
        "startLine": 235,
        "startChar": 46,
        "endLine": 235,
        "endChar": 51
      },
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39a45375_4e741e11",
        "filename": "src/objects/js-atomics-synchronization.h",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-13T23:54:12Z",
      "side": 1,
      "message": "Woops, this one is feels bad ðŸ˜‚",
      "parentUuid": "6cb5166b_f9846bb3",
      "range": {
        "startLine": 235,
        "startChar": 46,
        "endLine": 235,
        "endChar": 51
      },
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ae08f143_47af7045",
        "filename": "src/objects/js-atomics-synchronization.h",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-05-14T01:37:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "39a45375_4e741e11",
      "range": {
        "startLine": 235,
        "startChar": 46,
        "endLine": 235,
        "endChar": 51
      },
      "revId": "051d73a47dd891fe9e5e705176b1eaafbd60ed16",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}